import { QUESTIONS } from "@/constants/questions";

export const compileFiles = (ans: Record<number, string | string[] | undefined>) => {
    const results: Record<string, string> = {};

    const getLabel = (questionId: number, idOrLabel: string | undefined): string => {
        if (!idOrLabel || idOrLabel === "NOT_DEFINED") return "";
        const question = QUESTIONS.find(q => q.id === questionId);
        if (!question) return idOrLabel;
        const option = question.options.find(o => o.id === idOrLabel);
        return option ? option.label : idOrLabel;
    };

    const getLabels = (questionId: number, idsOrLabels: string[] | string | undefined): string[] => {
        const items = Array.isArray(idsOrLabels) ? idsOrLabels : (typeof idsOrLabels === 'string' ? [idsOrLabels] : []);
        return items.map(item => getLabel(questionId, item)).filter(Boolean);
    };

    const getString = (id: number, fallback: string = ""): string => {
        const val = ans[id];
        if (Array.isArray(val)) return val.join(' + ');
        return (val as string) || fallback;
    };

    const getArray = (id: number): string[] => {
        const val = ans[id];
        if (Array.isArray(val)) return val;
        if (typeof val === 'string') return [val];
        return [];
    };

    const projectMission = getString(0, 'Mission not described');
    const projectType = getLabel(1, getString(1)) || 'General System';

    const techArray = getArray(3);
    const projectTech = techArray.length > 0 ? getLabels(3, techArray).join(', ') : 'Standard Stack';

    const structArray = getArray(2);
    const projectStructure = structArray.length > 0 ? getLabels(2, structArray).join(' + ') : 'Standard Architecture';

    const forbiddenArray = getArray(10);
    const forbiddenDirs = forbiddenArray.length > 0 ? getLabels(10, forbiddenArray).map(p => `\`${p}\``).join(', ') : 'None Specified';

    const priority = (getLabel(17, getString(17)) || 'Quality').toUpperCase();
    const enabledAgentsIds = getArray(5);
    const finalAgentsIds = enabledAgentsIds.length > 0
        ? (enabledAgentsIds.includes('planner') ? enabledAgentsIds : ['planner', ...enabledAgentsIds])
        : ['planner', 'architect', 'codewriter', 'reviewer'];

    const enabledAgentsMd = finalAgentsIds.map((id: string) => {
        const label = getLabel(5, id);
        return `*   **${label}** (${id}): Specialized unit for ${priority} within ${projectTech} context.`;
    }).join('\n');

    const generationDate = new Date().toISOString().split('T')[0];

    const optimization = getLabel(16, getString(16));
    const style = getLabel(18, getString(18));
    const documentation = getLabel(15, getString(15));
    const topology = getLabel(12, getString(12));
    const interface_sync = getLabel(13, getString(13));
    const conflict = getLabel(14, getString(14));
    const autonomy = getLabel(11, getString(11));

    // 1. AGENTS.md - Corporate Level Governance
    results['AGENTS.md'] = `---
type: governance_policy
version: 1.4.0
status: operational
last_revised: ${generationDate}
---

# ðŸ¤– AGENTIC GOVERNANCE AND SYSTEM ARCHITECTURE

## 1. STRATEGIC MISSION & CONTEXT
**CORE GOAL:** ${projectMission}
**PROJECT TYPE:** ${projectType}
**TARGET ARCHITECTURE:** ${projectStructure}

## 2. TECHNICAL ECOSYSTEM
*   **PRIMARY STACK:** ${projectTech || 'NOT_DETERMINED'}
*   **DEPENDENCY MGMT:** ${getLabel(4, getString(4))}
*   **PRIORITY FOCUS:** ${priority}
*   **OPTIMIZATION:** ${optimization}

## 3. OPERATIONAL FRAMEWORK: THE ITERATIVE LOOP
All agents MUST strictly follow the **GOAL-PLAN-EXECUTE-VALIDATE** protocol:
1.  **GOAL:** Parse objectives from User or Strategic Planner.
2.  **PLAN:** Decompose into atomic, verifiable steps in \`.agent/state.json\`.
3.  **EXECUTE:** Implement using specialized SOPs (Standard Operating Procedures).
4.  **VALIDATE:** Automatic verification via tests, linters, and Reviewer agents.

## 4. AGENT REGISTRY & CAPABILITIES
${enabledAgentsMd}

## 5. SECURITY & ACCESS CONTROL (RBAC)
### 5.1 FILESYSTEM PERMISSIONS
*   **CREATE:** ${getLabel(6, getString(6)).toUpperCase()}
*   **MODIFY:** ${getLabel(7, getString(7)).toUpperCase()}
*   **DELETE:** ${getLabel(8, getString(8)).toUpperCase()}
*   **FORBIDDEN PATHS:** ${forbiddenDirs}

### 5.2 VERSION CONTROL
*   **GIT ACCESS:** ${getLabel(9, getString(9))}

## 6. WORKFLOW CONFIGURATION
*   **TOPOLOGY:** ${topology}
*   **AUTONOMY:** ${autonomy}
*   **SYNC METHOD:** ${interface_sync}
*   **CONFLICT RESOLUTION:** ${conflict}

---
*Generated by AI Agent Builder Architect*
`;

    // 2. agents-config.json - Machine readable
    results['agents-config.json'] = JSON.stringify({
        schema_version: "1.4.0",
        metadata: {
            generated_at: generationDate,
            mission: projectMission,
            target_env: getString(1),
            tech_base: getArray(3)
        },
        registry: finalAgentsIds.map((id: string) => {
            const isPlanner = id === 'planner';
            return {
                uid: id,
                role: getLabel(5, id),
                type: isPlanner ? "orchestrator" : "worker",
                priority: isPlanner ? 1 : 2,
                permissions: {
                    fs: {
                        create: isPlanner ? "full" : getString(6),
                        edit: isPlanner ? "any" : getString(7),
                        delete: isPlanner ? "never" : getString(8)
                    },
                    vcs: getString(9),
                    forbidden: getArray(10)
                }
            };
        }),
        orchestration: {
            method: getString(12),
            interface: getString(13),
            autonomy: getString(11),
            state_path: ".agent/state.json"
        }
    }, null, 2);

    // 3. prompts/planner.md
    results['prompts/planner.md'] = `---
role: STRATEGIC_PLANNER
domain: ${projectType}
stack: ${projectTech}
type: orchestrator
---

# SOP: STRATEGIC PLANNER OPERATIONAL DIRECTIVE

## 1. PROJECT CONTEXT
**MISSION:** ${projectMission}
**TECH STACK:** ${projectTech}

## 2. CORE RESPONSIBILITIES
1. **ORCHESTRATION:** Maintain the Global State and coordinate all worker agents.
2. **DECOMPOSITION:** Break down complex human goals into atomic tasks.
3. **VALIDATION:** Verify that every step aligns with the MISSION.

## 3. STATE MANAGEMENT
*   **READ:** Always check \`.agent/state.json\` before planning.
*   **WRITE:** Update state immediately after any decision or delegation.

## 4. DECISION LOGIC
- Use **${topology}** topology for agent interaction.
- Maintain **${autonomy}** level of autonomy.
`;

    // 4. Worker Prompts
    finalAgentsIds.filter(id => id !== 'planner').forEach((id: string) => {
        const label = getLabel(5, id);
        results[`prompts/${id}.md`] = `---
role: ${id.toUpperCase()}
name: ${label}
domain: ${projectType}
stack: ${projectTech}
type: worker
---

# SOP: ${label.toUpperCase()} OPERATIONAL DIRECTIVE

## 1. MISSION ALIGNMENT
**PROJECT GOAL:** ${projectMission}
** YOUR ROLE:** You are the ${label}. Your output must be focused on **${priority}**.

## 2. OPERATIONAL PROTOCOL
1. **SYNC:** Check current task in \`memory/current_task.md\`.
2. **EXECUTE:** Implement the assigned task following **${style}** style.
3. **DOCUMENT:** Provide **${documentation}** comments.

## 3. CONSTRAINTS
*   **FORBIDDEN:** ${forbiddenDirs}
*   **AUTO-OPTIMIZE:** ${optimization}
`;
    });

    // 5. State & Memory Template
    results['.agent/state.json'] = JSON.stringify({
        status: "initialized",
        goal: projectMission,
        current_step: 0,
        plan: []
    }, null, 2);

    results['memory/current_task.md'] = `# CURRENT TASK: INITIALIZING ${projectType.toUpperCase()}
**Mission:** ${projectMission}
**Status:** âšª Ready for Planner

---
## PROGRESS
* [ ] Initial system check
* [ ] Architecting foundation
`;

    // 6. README-agents.md
    results['README-agents.md'] = `# SYSTEM INTEGRATION: AGENTIC CORE

## GETTING STARTED
1. Install dependencies: \`${getLabel(4, getString(4))}\`
2. Review \`AGENTS.md\` for governance policies.
3. Initialize the Strategic Planner with the following mission:
> ${projectMission}

## FOLDER STRUCTURE
* \`prompts/\`: Individual agent personalities and SOPs.
* \`.agent/\`: Machine-readable system state.
* \`memory/\`: Human-readable task logs.

---
*Generated at ${generationDate}*
`;

    return results;
};

